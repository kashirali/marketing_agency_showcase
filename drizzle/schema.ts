import { integer, sqliteTable, text } from "drizzle-orm/sqlite-core";
import { sql } from "drizzle-orm";

/**
 * Core user table backing auth flow.
 * Extend this file with additional tables as your product grows.
 * Columns use camelCase to match both database fields and generated types.
 */
export const users = sqliteTable("users", {
  /**
   * Surrogate primary key. Auto-incremented numeric value managed by the database.
   * Use this for relations between tables.
   */
  id: integer("id").primaryKey({ autoIncrement: true }),
  /** Manus OAuth identifier (openId) returned from the OAuth callback. Unique per user. Optional for local auth. */
  openId: text("openId").unique(),
  name: text("name"),
  email: text("email").notNull().unique(),
  password: text("password"), // Hashed password for local auth
  loginMethod: text("loginMethod"),
  role: text("role", { enum: ["user", "admin"] }).default("user").notNull(),
  createdAt: integer("createdAt", { mode: "timestamp" }).default(sql`(unixepoch())`).notNull(),
  updatedAt: integer("updatedAt", { mode: "timestamp" }).default(sql`(unixepoch())`).notNull(),
  lastSignedIn: integer("lastSignedIn", { mode: "timestamp" }).default(sql`(unixepoch())`).notNull(),
});

export type User = typeof users.$inferSelect;
export type InsertUser = typeof users.$inferInsert;

/**
 * Social media accounts configuration table
 * Stores API credentials and settings for different social media platforms
 */
export const socialMediaAccounts = sqliteTable("social_media_accounts", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  userId: integer("userId").notNull(),
  platform: text("platform", { enum: ["linkedin", "facebook", "twitter", "instagram"] }).notNull(),
  accountName: text("accountName").notNull(),
  accessToken: text("accessToken").notNull(),
  refreshToken: text("refreshToken"),
  accountId: text("accountId").notNull(),
  isActive: integer("isActive", { mode: "boolean" }).default(true).notNull(),
  createdAt: integer("createdAt", { mode: "timestamp" }).default(sql`(unixepoch())`).notNull(),
  updatedAt: integer("updatedAt", { mode: "timestamp" }).default(sql`(unixepoch())`).notNull(),
});

export type SocialMediaAccount = typeof socialMediaAccounts.$inferSelect;
export type InsertSocialMediaAccount = typeof socialMediaAccounts.$inferInsert;

/**
 * AI-generated social media posts
 * Stores content generated by the AI agent for each platform
 */
export const generatedPosts = sqliteTable("generated_posts", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  userId: integer("userId").notNull(),
  platform: text("platform", { enum: ["linkedin", "facebook", "twitter", "instagram"] }).notNull(),
  title: text("title").notNull(),
  content: text("content").notNull(),
  agentId: integer("agentId"), // Link to specific agent config
  hashtags: text("hashtags"), // JSON array stored as text
  status: text("status", { enum: ["draft", "scheduled", "published", "failed"] }).default("draft").notNull(),
  mediaUrl: text("mediaUrl"),
  mediaType: text("mediaType", { enum: ["image", "video", "carousel"] }),
  mediaPrompt: text("mediaPrompt"),
  externalPostId: text("externalPostId"),
  scheduledAt: integer("scheduledAt", { mode: "timestamp" }),
  publishedAt: integer("publishedAt", { mode: "timestamp" }),
  createdAt: integer("createdAt", { mode: "timestamp" }).default(sql`(unixepoch())`).notNull(),
});

export type GeneratedPost = typeof generatedPosts.$inferSelect;
export type InsertGeneratedPost = typeof generatedPosts.$inferInsert;

/**
 * AI Agent Configuration
 * Stores settings for the automated posting agent
 */
export const aiAgentConfig = sqliteTable("ai_agent_config", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  userId: integer("userId").notNull(),
  agentName: text("agentName").notNull(),
  isActive: integer("isActive", { mode: "boolean" }).default(true).notNull(),
  postingSchedule: text("postingSchedule"), // JSON object stored as text
  platforms: text("platforms"), // JSON array stored as text
  contentStyle: text("contentStyle"),
  maxPostsPerDay: integer("maxPostsPerDay").default(3).notNull(),
  includeImages: integer("includeImages", { mode: "boolean" }).default(true).notNull(),
  includeHashtags: integer("includeHashtags", { mode: "boolean" }).default(true).notNull(),
  agencyInfo: text("agencyInfo"), // JSON object stored as text
  selectedAccounts: text("selectedAccounts"), // JSON object mapping platform -> accountId
  nextRunAt: integer("nextRunAt", { mode: "timestamp" }),
  createdAt: integer("createdAt", { mode: "timestamp" }).default(sql`(unixepoch())`).notNull(),
  updatedAt: integer("updatedAt", { mode: "timestamp" }).default(sql`(unixepoch())`).notNull(),
});

export type AIAgentConfig = typeof aiAgentConfig.$inferSelect;
export type InsertAIAgentConfig = typeof aiAgentConfig.$inferInsert;

/**
 * Posting logs
 * Tracks all posting attempts and their results
 */
export const postingLogs = sqliteTable("posting_logs", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  userId: integer("userId").notNull(),
  postId: integer("postId").notNull(),
  agentId: integer("agentId"),
  platform: text("platform", { enum: ["linkedin", "facebook", "twitter", "instagram"] }).notNull(),
  status: text("status", { enum: ["success", "failed", "pending"] }).notNull(),
  platformPostId: text("platformPostId"),
  errorMessage: text("errorMessage"),
  attemptedAt: integer("attemptedAt", { mode: "timestamp" }).default(sql`(unixepoch())`).notNull(),
});

export type PostingLog = typeof postingLogs.$inferSelect;
export type InsertPostingLog = typeof postingLogs.$inferInsert;

/**
 * Content templates
 * Reusable templates for content generation
 */
export const contentTemplates = sqliteTable("content_templates", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  userId: integer("userId").notNull(),
  name: text("name").notNull(),
  platform: text("platform", { enum: ["linkedin", "facebook", "twitter", "instagram"] }).notNull(),
  template: text("template").notNull(),
  variables: text("variables"), // JSON array stored as text
  createdAt: integer("createdAt", { mode: "timestamp" }).default(sql`(unixepoch())`).notNull(),
  updatedAt: integer("updatedAt", { mode: "timestamp" }).default(sql`(unixepoch())`).notNull(),
});

export type ContentTemplate = typeof contentTemplates.$inferSelect;
export type InsertContentTemplate = typeof contentTemplates.$inferInsert;